# 环境变量

- [环境变量](#环境变量)
  - [环境变量介绍](#环境变量介绍)
  - [设置环境变量](#设置环境变量)
    - [设置局部用户变量](#设置局部用户变量)
    - [设置全局环境变量](#设置全局环境变量)
  - [删除环境变量](#删除环境变量)
  - [默认的shell环境变量](#默认的shell环境变量)
  - [设置PATH环境变量](#设置path环境变量)
  - [定位系统环境变量](#定位系统环境变量)
    - [bash作为登陆shell](#bash作为登陆shell)
    - [bash作为交互式shell](#bash作为交互式shell)
    - [bash作为非交互式shell](#bash作为非交互式shell)
      - [可拆卸式认证模块(PAM)](#可拆卸式认证模块pam)
  - [数组变量](#数组变量)


## 环境变量介绍

- 环境变量用于存储有关shell会话和工作环境的信息。运行在内存中存储数据以便程序或shell中运行的脚本能够访问到。
- 程序和脚本都通过环境变量来获取系统信息，存储临时数据和配置信息。、
- 系统环境变量基本上是全大写字母区别于普通用户的环境变量。
- 可使用env和printenv命令输出全局变量.
- 可使用echo $(env)显示变量的值，此时引用某个环境变量，必须在变量前加$。
- 在变量名前加$可以显示变量当前的值，并且能让变量作为命令行参数
  - printenv (env)显示个别环境变量的值可以使用printenv,不使用env
- 分为全局变量和局部变量
  - 全局变量
    - 对于当前shell会话和生成的子shell都是可见的。创建的子shell可以获取父shell信息。
  - 局部变量
    - 只能在定义它们的进程中可见。
    - 没有只显示局部环境变量的命令
      - set命令会显示某个特定进程设置的所有环境变量，包括局部变量，全局变量，用户定义变量。
- env,printenv,set的区别
  - set命令会显示全局变量，局部变量以及用户定义变量，还会按照字母顺序对结果进行排序。
  - env会对变量排序，也不会输出局部变量和用户定义变量，能在指定环境中执行命令。
  - printenv不会对变量排序，也不会输出局部变量和用户定义变量，能显示环境变量的值。

## 设置环境变量

### 设置局部用户变量

- 可以通过'='给环境变量赋值，值可以是数值或字符串。
- 如果要给变量赋值为一个含有空格的字符串，必须使用单引号来界定字符串的首尾。否则shell会认为下一个词是另一个要执行的命令
- 三种类型
  - a=b,将变量a设置为b,不会进行处理。
  - a='b'，会将b是为字符串，不会进行字符串替换或其他特殊处理。
  - a="b"，会对字符串进行变量替换和转义字符解析，如果字符串中包含变量或特殊字符会进行解析。
- 环境变量变量定义时，变量名，等号和值之间没有空格。如果含有空格就会将值当作单独的命令。

### 设置全局环境变量

- 创建全局变量的方法是先创建局部环境变量，再将其导入到全局变量。
- 使用exprot env实现，变量名前不需要加$
- 重启后重置
- 修改子shell中全局变量并不会影响到父shell中该变量的值。
- 子shell无法使用export改变父shell中全局变量的值。

## 删除环境变量

- 使用unset env可以删除环境变量，不需要使用$
  - 需要使用变量时使用$，如果要操作变量，不使用$，但printenv输出全局变量值时不需要$
- 在子进程中删除一个全局变量只对子进程有效，该全局环境变量在父进程中仍可使用，和修改变量一样，在子shell中删除全局变量无法反映到父shell中。

## 默认的shell环境变量

- shell会使用一些特定的环境变量来定义系统环境。
- 不是所有的默认环境变量都会在set命令中列出。默认环境变量并不是每个都必须有一个值。

## 设置PATH环境变量

- PATH环境变量定义了用于进行命令和程序查找的目录。
- PATH中的目录使用冒号分隔。
- 如果命令或者程序的位置没有包括在PATH变量中，那么如果不使用绝对路径，shell是没办法找到该程序的。
- 应用程序放置可执行文件的目录常常不在PATH环境变量所包含的目录中，可以将PATH环境变量包含所有存放应用程序的目录。
- 可以将新的搜索目录添加到现有的PATH环境变量中，无需重头定义。
- 如PATH=$PATH:/目录
- 可以将单点符添加到PATH,对PATH变量的修改只能持续到退出或重启系统，不能一直持续。

## 定位系统环境变量

- 默认情况下shell会在几个文件中查找命令，这些文件叫做**启动文件**或**环境文件**。
- /etc/profile在每次升级开发板后都会重置。因此要让全局变量持久化可以将新的或修改后的全局变量存在一个以.sh为拓展名的文件，放在/etc/profile.d中。
- 存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。如果设置*BASH_ENV*变量，除非它指向的是$HOME/.bashrc，否则应该将非交互式shell的用户变量放在*BASH_ENV*指向的文件。
- 可以将alias命令放在.bashrc中持久生效。
- shell检查的启动文件取决于启动shell的方式。
  - 登陆时作为默认登陆shell
  - 作为非登陆shell的交互式shell
  - 作为运行脚本的非交互shell

### bash作为登陆shell

- 读取的启动文件
  - /etc/profile
  - $HOME/.bash_profile
  - $HOME/.bashrc
  - $HOME/.bash_login
  - $HOME/.profile
- /etc/profile文件是系统上默认的bash shell的主启动目录，系统上的每个用户登陆时都会执行这个启动文件。会迭代/etc/profile.d目录下的所有文件，这为linux系统提供了一个放置特定应用程序启动文件的地方。
- /etc/profile.d中有些文件与系统中的特定应用有关，大部分应用都会创建两个启动文件，一个供bash shell调用(使用.sh拓展名)，另一种供c shell使用(使用.csh拓展名)
- 另外四个启动文件是针对用户的，提供一个用户专属的启动文件来定义该用户所用到的环境变量。这些环境变量会在每次启动bash shell会话时生效。
  - 会依次读取文件，找到一个后剩下的就会被忽略
    1. $HOME/.bash_profile
    2. $HOME/.bash_login
    3. $HOME/.profile
  - $HOME/.bashrc通常是通过其他文件运行的。

### bash作为交互式shell

- 不是登陆系统时启动的shell,则为交互式shell.
- 不会访问/etc/profile，只会检查用户HOME目录中的.bashrc文件。
- .bashrc的作用
  - 查看/etc下通用的bashrc文件
  - 为用户提供一个定制自己的命令别名和私有脚本函数

### bash作为非交互式shell

- 没有命令提示符
- bash shell提供*BASH_ENV*环境变量，当shell启动一个非交互式shell进程时，会检查这个环境变量来查看要执行的启动文件，如果有指定的文件，shell会执行该文件里的命令，通常包括shell脚本变量设置。
- 如果*BASH_ENV*变量没有设置，子shell会继承父shell中的全局变量。

#### 可拆卸式认证模块(PAM)

- PAM文件会在bash shell启动之前处理，这些文件中可能包含环境变量。
- PAM包含/etc/environment和$HOME/.pam_environment

## 数组变量

- 环境变量可以作为数组使用。
- 给某个环境变量设置多个值可以将值放在()中，用空格分隔。如a=(a b c d e f)
- 用变量名输出，只会输出第一个值。
- 要引用一个单独的数组元素，必须使用代表它的数值索引值，如输出第二个echo ${a[1]}
- 显示整个数组变量可用*作为通配符放在索引值的位置。
- 在zsh中可以用数组变量名输出数组，并且数组的序号是从1开始
- 可以使用unset删除数组中的某个值,在zsh将数组名及索引当作文件名模式来进行匹配因此会失败，要将数组名及索引放在引号中。删除数组中的值后该值不会显示，且后续的值不会向前补充。